'use client';

import React, { useEffect, useRef, useState } from 'react';

// åˆå¹¶çš„ Shader Park ä»£ç  - ç»“åˆ Mochi è´¨æ„Ÿå’Œ Metaball æ•ˆæœ
const spCode = `
  setMaxIterations(8);
  
  // è¾“å…¥å‚æ•°
  let click = input();
  let buttonHover = input();
  let offset = .1;
  
  function fbm(p) {
    return vec3(
      noise(p),
      noise(p+offset),
      noise(p+offset*2),
    )
  }
  
  // åº”ç”¨ Mochi è´¨æ„Ÿ - å‚è€ƒ MochiCanvas.tsx
  let s = getRayDirection();
  let n = sin(fbm(s+vec3(0, 0, -time*.1))*2)*.5+.75;
  n = pow(n, vec3(8));
  color(n);
  let scale = .5+n.x*.05;
  
  // åˆ›å»ºå¤šä¸ª Metaball - å‚è€ƒ ref/metaball.js
  sphere(0.3);
  displace(mouse.x, mouse.y, 0);
  blend(0.2);
  sphere(0.3);
  
  // æ·»åŠ æ›´å¤šçƒä½“å½¢æˆ Metaball æ•ˆæœ
  displace(mouse.x * 0.5, mouse.y * 0.5, 0);
  sphere(0.2);
  blend(0.1);
  
  // ç¬¬ä¸‰ä¸ªçƒä½“
  displace(mouse.x * -0.3, mouse.y * -0.3, 0);
  sphere(0.25);
  blend(0.15);
  
  // ç¬¬å››ä¸ªçƒä½“
  displace(mouse.x * 0.8, mouse.y * -0.2, 0);
  sphere(0.18);
  blend(0.12);
  
  // ç¬¬äº”ä¸ªçƒä½“
  displace(mouse.x * -0.6, mouse.y * 0.4, 0);
  sphere(0.22);
  blend(0.1);
`;

export default function CombinedPage() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // äº¤äº’çŠ¶æ€ç®¡ç†
  const [state, setState] = useState({
    buttonHover: 0.0,
    currButtonHover: 0.0,
    click: 0.0,
    currClick: 0.0,
    ballCount: 8.0,
    blendStrength: 0.4,
    mochiIntensity: 0.6
  });

  useEffect(() => {
    let cleanup: (() => void) | undefined;

    const initShaderPark = async () => {
      try {
        console.log('ğŸ¨ åˆå§‹åŒ–åˆå¹¶é¡µé¢ Shader Park...');
        
        // ç­‰å¾…å…¨å±€ Shader Park åŠ è½½å®Œæˆ
        let attempts = 0;
        while (!(window as any).shaderParkReady && attempts < 100) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        if (!(window as any).shaderParkReady) {
          throw new Error('Shader Park å…¨å±€åŠ è½½è¶…æ—¶');
        }
        
        const sculptToMinimalRenderer = (window as any).sculptToMinimalRenderer;
        
        if (typeof sculptToMinimalRenderer !== 'function') {
          throw new Error(`sculptToMinimalRenderer is not a function, got: ${typeof sculptToMinimalRenderer}`);
        }
        
        if (!canvasRef.current) {
          setError('Canvas element not found');
          return;
        }

        const canvas = canvasRef.current;

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        const resizeCanvas = () => {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.min(window.devicePixelRatio, 2);
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
        };

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // é¼ æ ‡äº‹ä»¶å¤„ç†
        const handleMouseOver = () => {
          setState(prev => ({ ...prev, buttonHover: 5 }));
        };

        const handleMouseOut = () => {
          setState(prev => ({ ...prev, buttonHover: 0.0 }));
        };

        const handleMouseDown = (e: MouseEvent) => {
          e.preventDefault();
          setState(prev => ({ ...prev, click: 1.0 }));
        };

        const handleMouseUp = (e: MouseEvent) => {
          e.preventDefault();
          setState(prev => ({ ...prev, click: 0.0 }));
        };

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        canvas.addEventListener('mouseover', handleMouseOver, false);
        canvas.addEventListener('mouseout', handleMouseOut, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
        canvas.addEventListener('mouseup', handleMouseUp, false);

        // å¯åŠ¨ Shader Park æ¸²æŸ“å™¨
        sculptToMinimalRenderer(canvas, spCode, () => {
          setState(prev => ({
            ...prev,
            currButtonHover: prev.currButtonHover * 0.999 + prev.buttonHover * 0.001,
            currClick: prev.currClick * 0.92 + prev.click * 0.08
          }));
          
          return {
            'buttonHover': state.currButtonHover,
            'click': state.currClick,
            'ballCount': state.ballCount,
            'blendStrength': state.blendStrength,
            'mochiIntensity': state.mochiIntensity
          };
        });

        setIsLoaded(true);

        // æ¸…ç†å‡½æ•°
        cleanup = () => {
          window.removeEventListener('resize', resizeCanvas);
          canvas.removeEventListener('mouseover', handleMouseOver);
          canvas.removeEventListener('mouseout', handleMouseOut);
          canvas.removeEventListener('mousedown', handleMouseDown);
          canvas.removeEventListener('mouseup', handleMouseUp);
        };

      } catch (err) {
        console.error('âŒ åˆå¹¶é¡µé¢ Shader Park åˆå§‹åŒ–å¤±è´¥:', err);
        setError(`Failed to load Combined Shader Park: ${err instanceof Error ? err.message : 'Unknown error'}`);
      }
    };

    initShaderPark();

    return () => {
      if (cleanup) {
        cleanup();
      }
    };
  }, []);

  if (error) {
    return (
      <div className="flex items-center justify-center bg-gray-900 text-red-400 min-h-screen">
        <div className="text-center">
          <h3 className="text-lg font-semibold mb-2">æ¸²æŸ“é”™è¯¯</h3>
          <p className="text-sm">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-black">
      {/* ç®€åŒ–çš„æ ‡é¢˜ */}
      <div className="absolute top-4 left-4 z-10 text-white">
        <div className="bg-gray-900/80 backdrop-blur-sm rounded-xl p-4">
          <h1 className="text-xl font-bold text-purple-200">åˆå¹¶æ•ˆæœ</h1>
          <p className="text-xs text-gray-300">Metaball äº¤äº’ + Mochi è´¨æ„Ÿ</p>
        </div>
      </div>

      {/* è¿”å›æŒ‰é’® */}
      <div className="absolute bottom-4 right-4 z-10">
        <a 
          href="/"
          className="bg-white/10 hover:bg-white/20 backdrop-blur-sm text-white px-4 py-2 rounded-lg transition-colors text-sm"
        >
          è¿”å›é¦–é¡µ
        </a>
      </div>

      {/* ä¸»ç”»å¸ƒ */}
      <div className="relative bg-black w-full h-screen">
        <canvas 
          ref={canvasRef}
          className="w-full h-full cursor-pointer"
          style={{ 
            width: '100%', 
            height: '100%',
            minHeight: '400px'
          }}
        />
        {!isLoaded && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-900 text-white">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto mb-4"></div>
              <p>åŠ è½½ä¸­...</p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
